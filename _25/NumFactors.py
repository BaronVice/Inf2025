# 1) Пусть число A является делителем N, тогда и B, результат N // A = B, является делителем N.
# 2) Наименьшему A соответствует наибольший B (N = 100: A = 1 -> B = 100; A = 2 -> B = 50; A = 4 -> B = 25; ...)
# 3) A имеет смысл перебирать от 1 до N**0.5 (корень), поскольку для большего A нет ранее не найденного B.
# 4) Если ни одно из чисел от 2 до N**0.5 не является делителем N, то N простое.

# Напишем функцию для нахождения делителей числа N
def f(n):
    # Выбираем set(), чтобы исключить повторения делителей A и B: например для N=100 возможно A=10, B=10
    divs = set()
    # Алгоритм: перебор A до корня N
    a = 1
    # чтобы не работать с дробными перепишу a <= n**0.5 как
    while a * a <= n:
        # Если N делится на A
        if n % a == 0:
            # То добавляю A к делителям
            divs.add(a)
            # Как и B
            b = n // a
            divs.add(b)
        a += 1

    # Что писать в return - зависит от задачи
    # Количество делителей -> len(divs)
    # Делители в порядке возрастания -> sorted(divs)
    # Делители в порядке убывания -> sorted(divs, reverse=True)
    return sorted(divs)

print(f(100))
