def good(n):
    bin_n = bin(n)[2:]
    for i in range(3):
        num = int(bin_n, 2)
        s = str(num)
        odd = 0 # нечетные
        even = 0 # четные
        for digit in s:
            if int(digit) % 2 == 0:
                even += 1
            else:
                odd += 1

        if even > odd:
            bin_n += "1"
        elif odd > even:
            bin_n += "0"
        else:
            if n % 2 == 0:
                bin_n += "0"
            else:
                bin_n += "1"

    r = int(bin_n, 2)
    # Следуюшие 4 строки можно заменить на return 876544 <= r <= 1234567899, но чтобы было понятно:
    if 876544 <= r <= 1234567899:
        return True
    else:
        return False

# минимальное r = 876544, в двоичной записи это 11010110000000000000, уберем последние три бита
# и переведем в десятичную с.с. -> получим начальное n от которого будем искать n1 - первое n,
# при котором получим 876544 <= r <= 1234567899
n1 = 109568
# максимальное r = 1234567899, в двоичной записи это 1001001100101100000001011011011, проведем те же
# преобразования -> начальное n от которого будем искать n2 - последнее n, при котором
# получим 876544 <= r <= 1234567899
n2 = 154320987

# Пока не нашли начальное (n1) - прибавляем
while not good(n1): n1 += 1
# Пока последнее выполняется (n2) - прибавляем
while good(n2 + 1): n2 += 1

# Количество чисел = n2 - n1 + 1
print(n2 - n1 + 1)

    

