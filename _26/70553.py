# https://inf-ege.sdamgia.ru/problem?id=70553

file_location = "-- путь до файлика --"

with open(file_location, "r") as f:
    # Читаем строки из файлика, d - массив строк
    d = f.readlines()

# В первой строке - количество записей
n = int(d[0])
# С 1 по последнюю строку находятся данные: id студента и его 4 оценки
s = [list(map(int, x.split())) for x in d[1:]]
# В p будем записывать прошедших аттестацию, в f - проваливших
p, f = [], []

for x in s:
    # Если есть хотя бы одна двойка - провалил
    (p if 2 not in x[1:] else f).append(x)

# p хотим отсортировать по убыванию рейтинга (-y[1]),
# но если есть учащиеся с равным рейтингом, то упорядочим их по возрастанию id (y[0])

# sum(x[1:]) / 4 - средний балл
# key=lambda y: (-y[1], y[0]) - сортируй по убыванию по параметру y[1] (средний балл),
# но если значения равные, то по y[0] (id)
p = sorted([(x[0], sum(x[1:]) / 4) for x in p], key=lambda y: (-y[1], y[0]))

# key=lambda y: (y[1:].count(2), y[0]) - сортируй по количеству двоек,
# но если значения равные, то по y[0] (id)
f = sorted(f, key=lambda y: (y[1:].count(2), y[0]))

# Первые 20 значений прошедших
print(p[:20])
# 1) Последний, кто попадает на повышенную стипендию
# занимает место n // 4 - 1 в списке прошедших (последний в первых 25%)
# 2) Первый в рейтинговом списке студент с более чем двумя двойками:
# next(x[0] for x in f if x[1:].count(2) > 2) - пройдемся по всем f
# пока не найдем студента с x[1:].count(2) > 2
print(p[n // 4 - 1][0], next(x[0] for x in f if x[1:].count(2) > 2))